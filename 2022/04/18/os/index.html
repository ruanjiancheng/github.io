<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="write something interesting">
    <meta name="author" content="auggie">
    
    <title>
        
            内存管理 &amp; 文件管理 &amp; IO 管理 |
        
        Auggie&#39;s blog
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/logo.png">
    
<link rel="stylesheet" href="/fontawesome/css/fontawesome.min.css">

    
<link rel="stylesheet" href="/fontawesome/css/regular.min.css">

    
<link rel="stylesheet" href="/fontawesome/css/solid.min.css">

    
<link rel="stylesheet" href="/fontawesome/css/brands.min.css">

    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"example.com","root":"/","language":"zh","path":"search.xml"};
    KEEP.theme_config = {"toc":{"enable":true,"number":false,"expand_all":false,"init_open":false},"style":{"primary_color":"#0066CC","logo":"/images/logo.svg","favicon":"/images/logo.png","avatar":"/images/avatar.png","font_size":null,"font_family":null,"left_side_width":"260px","content_max_width":"920px","hover":{"shadow":false,"scale":false},"first_screen":{"enable":true,"header_transparent":true,"background_img":"/images/bg.svg","description":"Keep running and Keep loving.","font_color":null,"hitokoto":{"enable":false}},"scroll":{"progress_bar":{"enable":true},"percent":{"enable":true}}},"local_search":{"enable":false,"preload":false},"code_copy":{},"code_block_tools":{"enable":true,"style":"default"},"side_tools":{},"pjax":{"enable":false},"lazyload":{"enable":false},"version":"3.4.9"};
    KEEP.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
    KEEP.language_code_block = {"copy":"Copy code","copied":"Copied","fold":"Fold code block","folded":"Folded"};
  </script>
<meta name="generator" content="Hexo 5.4.2"></head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            
<header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            
                <a class="logo-image" href="/">
                    <img src="/images/logo.svg">
                </a>
            
            <a class="logo-title" href="/">
               Auggie&#39;s blog
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                首页
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                归档
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/about"
                            >
                                关于
                            </a>
                        </li>
                    
                    
                </ul>
            </div>
            <div class="mobile">
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">首页</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">归档</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/about">关于</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">内存管理 &amp; 文件管理 &amp; IO 管理</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/avatar.png">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">auggie</span>
                        
                    </div>
                    <div class="meta-info">
                        
<div class="article-meta-info">
    <span class="article-date article-meta-item">
        
            <i class="fa-regular fa-calendar-plus"></i>&nbsp;
        
        <span class="pc">2022-04-18 22:00:47</span>
        <span class="mobile">2022-04-18 22:00</span>
    </span>
    
        <span class="article-update-date article-meta-item">
        <i class="fas fa-file-pen"></i>&nbsp;
        <span class="pc">2022-10-09 23:47:04</span>
    </span>
    
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/%E6%8A%80%E6%9C%AF/">技术</a>&nbsp;
                    </li>
                
                    <li>
                        | <a href="/tags/os/">os</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fas fa-file-word"></i>&nbsp;<span>8.5k 字</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fas fa-clock"></i>&nbsp;<span>29 分钟</span>
        </span>
    
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><p>&#x3D;&#x3D;问题：缓和 CPU 和磁盘之间的速度矛盾&#x3D;&#x3D;</p>
<p>解决：引入内存</p>
<p>&#x3D;&#x3D;为什么需要内存管理？&#x3D;&#x3D;</p>
<p><strong>为了更好的支持多道程序并发执行</strong>。引入多道程序的并发执行之后，进程之间共享的不仅仅是处理机，还有内存。若不对内存进行管理，容易导致内存数据混乱。限制程序的并发性。</p>
<p><strong>内存管理的主要功能：</strong>内存分配、 内存保护、 地址映射和内存扩充。 </p>
<p><strong>主要任务：</strong></p>
<ul>
<li>内存分配：为每道程序分配内存</li>
<li>内存保护：确保每道用户程序都只能在自己的内存空间里运行，彼此互不干扰。</li>
<li>地址映射：将地址空间的逻辑地址转换为内存空间与相对应的物理地址。</li>
<li>内存扩充：用于实现请求调用功能，置换功能等</li>
</ul>
<h2 id="程序的执行过程"><a href="#程序的执行过程" class="headerlink" title="程序的执行过程"></a>程序的执行过程</h2><p>预处理 -&gt; 编译 -&gt; 汇编 -&gt; <strong>链接（形成完成的逻辑地址）</strong> -&gt; 装入</p>
<blockquote>
<p>装入</p>
</blockquote>
<ul>
<li><p>绝对装入</p>
<p>在<strong>编译</strong>时，直接产生绝对地址</p>
<p>缺点：只适用于单道程序环境</p>
</li>
<li><p>静态重定位 可重定位装入</p>
<p>编译和链接的时候，都是用的是相对地址。在<strong>装入</strong>时，产生绝对地址</p>
<p>缺点：</p>
<ul>
<li>装入内存时，就需要分配程序所要求的全部内存空间。没有足够内存时，不能分配</li>
<li>运行时不能移动</li>
</ul>
</li>
<li><p>动态重定位 动态运行时装入</p>
<p><strong>程序运行</strong>时，产生绝对地址。需要重定位寄存器的支持</p>
<p>优点：允许程序在内存中发生移动，可以实现紧凑</p>
</li>
</ul>
<blockquote>
<p>链接</p>
</blockquote>
<ul>
<li><p>静态链接</p>
<p>在链接程序中，直接完成链接</p>
</li>
<li><p>装入时动态链接</p>
<p>边装入边链接</p>
</li>
<li><p>运行时动态链接</p>
<p>程序执行时动态链接，<strong>以段为基础</strong></p>
</li>
</ul>
<h2 id="内存分配方式"><a href="#内存分配方式" class="headerlink" title="内存分配方式"></a>内存分配方式</h2><ul>
<li>连续分配	<ul>
<li>单一连续分配</li>
<li>固定分区分配</li>
<li>动态分区分配<ul>
<li>首次适应</li>
<li>循环首次适应</li>
<li>最佳适应</li>
<li>最坏适应</li>
<li>快速适应</li>
<li>伙伴系统</li>
</ul>
</li>
</ul>
</li>
<li>对换</li>
<li>离散分配<ul>
<li>基本分页存储管理</li>
<li>基本分段存储管理</li>
<li>请求分页存储管理</li>
<li>请求分段存储管理</li>
</ul>
</li>
</ul>
<h3 id="连续分配"><a href="#连续分配" class="headerlink" title="连续分配"></a>连续分配</h3><blockquote>
<p>单一连续分配</p>
</blockquote>
<p>内存被分为系统区和用户区。系统区在低地址部分，用户区在高地址部分。</p>
<p>优点：</p>
<ul>
<li><strong>实现简单</strong></li>
<li>无外部碎片</li>
<li><strong>可以采用覆盖技术扩充内存</strong> </li>
<li>不一定需要内存保护</li>
</ul>
<p>缺点：</p>
<ul>
<li>只能用于当用户、单任务操作系统</li>
<li>有内部碎片</li>
<li>存储器利用效率极低</li>
</ul>
<blockquote>
<p>固定分区分配</p>
</blockquote>
<p><strong>一个进程只能选择一个分区</strong></p>
<p>分区方式：</p>
<ul>
<li>分区大小相等：缺乏灵活性</li>
<li>分区大小不等：增加了灵活性，可以满足不同大小进程需求</li>
</ul>
<p>优点：</p>
<ul>
<li>实现简单</li>
</ul>
<p>缺点：</p>
<ul>
<li>当用户程序过大时，可能所有分区都不能满足需求</li>
<li>产生内部碎片，内存利用率低</li>
</ul>
<blockquote>
<p>动态分区分配 PPT P55</p>
</blockquote>
<ul>
<li><p>用什么数据结构记录空闲分区情况</p>
<ul>
<li>空闲分区表</li>
<li>空闲分区链</li>
</ul>
</li>
<li><p>分配算法</p>
<ul>
<li>首次适应<ul>
<li>空闲分区表以<strong>地址递增</strong>的次序排列</li>
<li>优点：优先利用内存低址部分的内存空间,保留了高址部分的大空闲区</li>
<li>缺点：<ul>
<li>低址部分不断划分，产生小碎片（内存碎块、零头）；</li>
<li>每次查找从低址部分开始，增加了查找的开销</li>
</ul>
</li>
</ul>
</li>
<li>循环首次适应<ul>
<li>从上次找到的空闲分区的<strong>下一个空闲分区开始查找</strong></li>
<li>优点：使内存空闲分区分布均匀，减少查找的开销</li>
<li>缺点：缺乏大的空闲分区</li>
</ul>
</li>
<li>最佳适应<ul>
<li>按其容量以<strong>从小到大</strong>的顺序</li>
<li>缺点：产生许多难以利用的小空闲区</li>
</ul>
</li>
<li>最坏适应<ul>
<li>按其容量以<strong>从大到小</strong>的顺序形成一空闲分区链</li>
<li>优点：剩下的空闲区还可以利用，同时查找效率很高。</li>
<li>缺点：缺乏大的空闲分区。</li>
</ul>
</li>
<li>快速适应（基于索引）<ul>
<li>问题：基于顺序搜索的动态分区分配算法，不适用于大型的系统。</li>
<li>引入：索引</li>
<li>根据其容量大小进行分类</li>
<li>优点：查找效率高，也不会产生内存碎片。</li>
<li>缺点：在分区归还主存时算法复杂，系统开销较大。</li>
</ul>
</li>
<li>伙伴系统（基于索引）<ul>
<li>按照 2 的整数幂将空闲分区分类</li>
<li>初始：整一个空间都是一块</li>
<li>分配：<ul>
<li>如果存在空闲分区，则分配</li>
<li>不然，向上查找分区，并且分裂</li>
</ul>
</li>
</ul>
</li>
<li>哈希算法<ul>
<li>通过 hash 实现，快速计算在 hash 表中的位置。</li>
</ul>
</li>
</ul>
<p>总结：</p>
<p><img src="/.com//image-20220419122112789.png" alt="image-20220419122112789"></p>
</li>
<li><p>回收算法</p>
<p>4 种情况</p>
</li>
</ul>
<p>优点：无内部碎片，有外部碎片</p>
<h3 id="覆盖"><a href="#覆盖" class="headerlink" title="覆盖"></a>覆盖</h3><p>&#x3D;&#x3D;问题：在小的内存空间运行大作业&#x3D;&#x3D;</p>
<p>覆盖是由程序员实现的，操作系统根据程序员提供的覆盖结构来完成<strong>程序段之间的覆盖</strong>。</p>
<p><img src="/.com//SouthEast.png" alt="图示"></p>
<p>子程序 C 运行完成之后，子程序 B 将其覆盖。</p>
<p>优点：扩充内存</p>
<p>缺点：对用户不透明，增加了用户负担。</p>
<h3 id="对换（交换）"><a href="#对换（交换）" class="headerlink" title="对换（交换）"></a>对换（交换）</h3><p>&#x3D;&#x3D;问题：在内存非常小的计算机上运行多道程序&#x3D;&#x3D;</p>
<p>条件：需要 IO 速度较高的外存</p>
<p>将内存中暂时不能运行或者暂时不用的数据和程序换出到外存上面。</p>
<p><strong>类型</strong></p>
<ol>
<li>整体对换：以进程为单位对换</li>
<li>部分对换：以页或者段为单位对换</li>
</ol>
<p>外存划分为：文件区、对换区</p>
<p><img src="/.com//image-20220419123417333.png" alt="image-20220419123417333"></p>
<p>优点：扩充内存</p>
<p><strong>覆盖与对换的区别</strong></p>
<ul>
<li>覆盖可<strong>减少一个进程运行所需的空间</strong>。对换可让整个进程暂存于外存中，<strong>让出内存空间</strong>。</li>
<li>覆盖是由<strong>程序员实现</strong>的，操作系统根据程序员提供的覆盖结构来完成程序段之间的覆盖。对换技术<strong>不要求程序员给出程序段之间的覆盖结构</strong>。</li>
<li>覆盖技术主要在<strong>同一个</strong>作业或进程中进行。对换主要在作业或进程<strong>之间</strong>进行。</li>
</ul>
<h3 id="离散分配"><a href="#离散分配" class="headerlink" title="离散分配"></a>离散分配</h3><h4 id="分页存储管理方式"><a href="#分页存储管理方式" class="headerlink" title="分页存储管理方式"></a>分页存储管理方式</h4><p>&#x3D;&#x3D;问题：固定分区分配会产生内部碎片，动态分区分配会产生外部碎片。对内存的利用率较低。同时希望尽量避免碎片的产生。&#x3D;&#x3D;</p>
<blockquote>
<p>什么是基本分页存储管理方式</p>
</blockquote>
<ul>
<li><p>不具备页面对换功能</p>
</li>
<li><p>不具有支持实现虚拟存储器的功能</p>
</li>
<li><p>要求把每个作业全部装入内存后方能运行</p>
</li>
</ul>
<blockquote>
<p>页面大小的选择</p>
</blockquote>
<p>小：</p>
<ul>
<li>内碎片小，内存利用率高</li>
<li>页表过长，占大量内存，管理开销大</li>
</ul>
<p>大：</p>
<ul>
<li>页表短，管理开销小</li>
<li>内碎片大，内存利用率低</li>
</ul>
<p>页面大小应当<strong>适中</strong></p>
<blockquote>
<p>地址变换机构</p>
</blockquote>
<ol>
<li><p>基本地址变换机构</p>
<p>需要页表寄存器 PTR</p>
<ol>
<li>判断页号是否越界</li>
<li>计算实际物理地址</li>
</ol>
<p>通过硬件自动完成</p>
<p>缺点：</p>
<ol>
<li>每次访存都需要进行地址变换（查询页表），降低速度 -&gt; TLB</li>
<li>每个进程引入页表，页表不能太大 -&gt; 多级页表</li>
</ol>
</li>
<li><p>具有快表的变换机构</p>
<p>需要快表（联想寄存器）</p>
<p>原理：程序的局部性</p>
</li>
<li><p>两级页表</p>
<p>&#x3D;&#x3D;问题：大页表占用大的连续存储空间&#x3D;&#x3D;</p>
<p>顶级页表 &#x3D; 页目录表 &#x3D; 外层页表</p>
<p>&#x3D;&#x3D;问题：没有必要让整个页表常驻内存，因为进程在一段时 间内可能只需要访问某几个特定的页面。&#x3D;&#x3D;</p>
<p>解决：类似于虚拟存储器，增加一位，是否在内存中。</p>
</li>
</ol>
<blockquote>
<p>优缺点</p>
</blockquote>
<p>优点：分页从根本上克服了外零头（地址空间、物理空间都分割）。<strong>内存利用率提高</strong>。</p>
<p>缺点：逻辑完整的信息分到不同的页面，<strong>执行速度降低</strong></p>
<h4 id="分段存储器"><a href="#分段存储器" class="headerlink" title="分段存储器"></a>分段存储器</h4><p>问题：克服分页的缺点</p>
<p>目的：满足用户的需求</p>
<blockquote>
<p>优点</p>
</blockquote>
<ul>
<li><p>便于编程</p>
<p><strong>用户</strong>常把自己的作业按逻辑关系划分成若干个段，每段都有自己的名字，且都从零开始编址。</p>
</li>
<li><p>信息共享</p>
<p>两个作业的段表项指向同一个共享的段。<strong>可重入代码</strong>可以共享（不属于临界资源）。</p>
</li>
<li><p>分段保护</p>
<ul>
<li>存取控制保护</li>
<li>地址越界保护</li>
</ul>
</li>
<li><p>动态链接</p>
</li>
<li><p>动态增长</p>
</li>
</ul>
<blockquote>
<p>特点</p>
</blockquote>
<p>段式的地址空间是二维的，因为没有办法给出一个整数便确定对应的物理地址。而<strong>需要显示的给出（段号，段内偏移量）</strong></p>
<blockquote>
<p>分段与分页的主要区别</p>
</blockquote>
<p>相同点：</p>
<ul>
<li>采用离散分配方式，通过地址映射机构实现地址变换</li>
</ul>
<p>不同点：</p>
<ul>
<li><strong>页是信息的物理单位</strong>，分页是为了满足系统的需要；<strong>段是信息的逻辑单位</strong>，含有意义相对完整的信息，是为了满足用户的需要。</li>
<li><strong>页的大小固定且由系统确定</strong>，由系统把逻辑地址分为页号和页内地址，由<strong>机器硬件实现</strong>；<strong>段的长度不固定</strong>，取决于用户程序，<strong>编译程序</strong>对源程序编译时根据信息的性质划分。</li>
<li>分页的作业地址空间是<strong>一维</strong>的；分段的作业地址空间是<strong>二维</strong>的,需要给出段名和段内地址。</li>
</ul>
<h4 id="段页式存储器"><a href="#段页式存储器" class="headerlink" title="段页式存储器"></a>段页式存储器</h4><blockquote>
<p>特点</p>
</blockquote>
<p>优点：</p>
<ul>
<li>分散存储，内存利用率较高</li>
<li>很好的满足用户需求，便于代码或数据共享，支持动态链接等</li>
</ul>
<p>缺点：</p>
<ul>
<li>一次访问转换成了三次访问</li>
</ul>
<p><img src="/.com//image-20220419145201131.png" alt="image-20220419145201131"></p>
<h3 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h3><blockquote>
<p>传统分配方式的特点</p>
</blockquote>
<ul>
<li>一次性：作业必须一次性全部装入内存后才能开始运行<ul>
<li>作业很大的时候，没有办法装入内存 -&gt; 覆盖</li>
<li>大量作业要求运行时，无法容纳所有作业，因此只有少量作业能运行，导致<strong>多道程序并发度下降</strong>。 -&gt; 对换</li>
</ul>
</li>
<li>驻留性：一旦作业被装入内存，就会一直驻留在内存中，直至作业运行结束。<strong>浪费内存资源</strong></li>
</ul>
<blockquote>
<p>思想 – 局部性原理</p>
</blockquote>
<p>TLB，cache 的思想</p>
<ul>
<li>时间局部性：如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行</li>
<li>空间局部性：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。</li>
</ul>
<blockquote>
<p>虚拟存储器</p>
</blockquote>
<p>定义：指具有<strong>请求调入</strong>（不在内存中）功能和<strong>置换</strong>（内存满了）功能，能从逻辑上对内存容量加以扩充的一种存储器系统。 -&gt; 建立在<strong>离散分配</strong>的基础上</p>
<p><strong>特点</strong>：</p>
<ul>
<li>多次性：无需在作业运行时一次性全部装入内存，而是允许被分成多次调入内存。</li>
<li>对换性：在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换入、换出。 </li>
<li>虚拟性：从逻辑上扩充了内存的容量，使用户看到的内存容量，远大 于实际的容量。</li>
</ul>
<p><strong>容量</strong></p>
<ul>
<li>虚拟内存的<strong>最大容量</strong>是由计算机的<strong>地址结构</strong>（CPU寻址范围）确定的</li>
<li>虚拟内存的<strong>实际容量</strong> &#x3D;min（内存 + 外存，CPU寻址范围）</li>
</ul>
<blockquote>
<p>硬件支持 P168 PPT P14</p>
</blockquote>
<ol>
<li><p>表机制</p>
<p><img src="/.com//image-20220419150330112.png" alt="image-20220419150330112"></p>
<p><img src="/.com//image-20220419153632043.png" alt="image-20220419153632043"></p>
<p>段式具有<strong>增补位</strong>，用于表示该段是否动态增长。</p>
</li>
<li><p>缺页&#x2F;段中断机构</p>
</li>
<li><p>地址变换机构</p>
</li>
<li><p>段的共享与保护 PPT P70</p>
<ol>
<li><p>共享：类似于索引节点的 DAG 图</p>
</li>
<li><p>保护</p>
<ol>
<li><p>越界检查</p>
</li>
<li><p>存取控制检查</p>
</li>
<li><p>环保护机构</p>
<p>OS 位于 0 环</p>
<p><img src="/.com//image-20220419154843734.png" alt="image-20220419154843734"></p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<blockquote>
<p>内存分配策略 P171</p>
</blockquote>
<ul>
<li><p><strong>最小物理块数的确定</strong>：保证进程正常运行所需的最小物理块数</p>
</li>
<li><p><strong>物理块分配策略</strong>：</p>
<ul>
<li><p>固定分配局部置换</p>
<p>为进程分配的物理块数在整个运行期间都<strong>不再改变</strong>。</p>
<p>缺点：难以确定每个进程分配的物理块数，太少导致频繁缺页中断；太多，导致资源利用率下降</p>
</li>
<li><p>可变分配全局置换</p>
<p>当进程发生缺页，若系统中有 空闲的物理块，则分配一个物理块并装入缺页；</p>
<p>优点：可以动态增加物理块数</p>
<p>缺点：盲目增加物理块，导致并发能力下降；被选中的进程缺页率增加</p>
</li>
<li><p>可变分配局部置换</p>
<p>若某个进程发生缺页，则只能将自己的某个内存页换出。OS <strong>根据缺页率</strong>进行物理块分配的调整</p>
</li>
</ul>
</li>
<li><p><strong>物理块的分配算法</strong>：</p>
<ul>
<li>平均分配算法<ul>
<li>将系统中所有可供分配的物理块，平均分配给各个进程。</li>
<li>缺点: <strong>未考虑各进程本身的大小</strong></li>
</ul>
</li>
<li>按比例分配算法<ul>
<li>根据<strong>进程的大小</strong>按比例分配物理块。</li>
</ul>
</li>
<li>考虑优先权的分配算法<ul>
<li>在实际应用中，为了<strong>照顾重要的、急迫的作业</strong>尽快完成，应为它<strong>分配较多</strong>的内存空间</li>
<li>算法：<ul>
<li>一部分按比例分配给各进程；</li>
<li>一部分则根据各进程的优先权，适当地增加其相应份额，分配给各进程</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>页面调入策略</p>
</blockquote>
<p><strong>何时调入页面</strong></p>
<ul>
<li>预调页策略<ul>
<li>主要用于进程的<strong>首次调入</strong>时，由<strong>程序员指出</strong>应该先调入哪些页。</li>
</ul>
</li>
<li>请求调页策略<ul>
<li>当程序在运行中需要访问某部分程序和数据时，若发现其所在的页面不在内存，便立即提出请求</li>
<li>优点：由请求调页策略所确定调入的页，<strong>一定会被访问</strong>；请求调页策略比较<strong>容易实现</strong></li>
<li>缺点：每次<strong>仅调入一页</strong>，需花费<strong>较大的系统开销</strong>，增加了磁盘 I&#x2F;O的启动频率。</li>
</ul>
</li>
</ul>
<p><strong>何处调入页面</strong></p>
<ul>
<li><p>系统拥有足够的对换区空间：可以<strong>全部从对换区调入所需页面</strong>，以提高调页速度</p>
<p><img src="/.com//image-20220419152036780.png" alt="image-20220419152036780"></p>
</li>
<li><p>系统缺少足够的对换区空间：</p>
<ul>
<li><strong>不会被修改的文件（不放入对换区）</strong>，直接从文件区调入；当换出这些页面时，因为未修改不用换出，再调入时仍从文件区调入。</li>
<li><strong>可能被修改的部分（放入对换区）</strong>，换出时需调到对换区，换入时从对换区调入；</li>
</ul>
<p><img src="/.com//image-20220419152050064.png" alt="image-20220419152050064"></p>
</li>
<li><p>UNIX 方式：</p>
<ul>
<li>第一次从文件区调入</li>
<li>再次使用的时候，从对换区调入</li>
</ul>
<p><img src="/.com//image-20220419152252225.png" alt="image-20220419152252225"></p>
</li>
</ul>
<blockquote>
<p>页面置换算法</p>
</blockquote>
<ul>
<li>OPT	<ul>
<li><strong>算法无法实现，但可评价其他算法</strong></li>
<li>优点：保证获得最低的缺页率</li>
<li>缺点：无法预知一个进程在内存的若干个页面，哪个在未来最长时间内不再被访问。</li>
</ul>
</li>
<li>FIFO<ul>
<li>Belady 异常——当为进程分配的物理块数增大时，缺页次数不减反增的异常现象。</li>
<li>只有 FIFO 会产生 Belady 异常</li>
</ul>
</li>
<li>LRU<ul>
<li>硬件实现：寄存器（最小值）、栈（栈顶）</li>
</ul>
</li>
<li>CLOCK<ul>
<li>最近未用算法（NRU，Not Recently Used）</li>
<li>算法：扫描访问位</li>
<li>操作系统还应考虑<strong>页面有没有被修改过</strong>。在其他条件都相同时，应<strong>优先淘汰没有修改过的页面</strong>，<strong>避免I&#x2F;O操作。</strong></li>
</ul>
</li>
</ul>
<p><img src="/.com//image-20220419152938106.png" alt="image-20220419152938106"></p>
<blockquote>
<p>抖动 &amp; 工作集 P184 PPT P60</p>
</blockquote>
<p><strong>定义</strong>：刚刚换出的页面马上又要换入内存，刚刚换入的页面马上又要换出外存，这种频繁的页面调度行为称为抖动，或颠簸。</p>
<p><strong>原因</strong>：进程频繁访问的页面数目高于可用的物理块数（<strong>分配给进程的物理块不够</strong>）</p>
<p><strong>预防方法</strong></p>
<ul>
<li>采取可变分配局部置换</li>
<li>把工作集算法融入到处理机调度中</li>
<li>利用“L&#x3D;S”准则调节缺页率</li>
<li>选择暂停的进程</li>
</ul>
<h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><p>文件系统的主要功能：</p>
<ul>
<li>对文件的基本操作</li>
<li>文件共享</li>
<li>文件保护</li>
<li>管理与磁盘的信息交换</li>
<li>完成逻辑结构 -&gt; 物理结构的转变</li>
</ul>
<p>文件系统结构：</p>
<p><img src="/.com//image-20220420105935784.png" alt="image-20220420105935784"></p>
<h2 id="文件系统的基本概念"><a href="#文件系统的基本概念" class="headerlink" title="文件系统的基本概念"></a>文件系统的基本概念</h2><h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><p>文件是存储在硬盘上的信息集合</p>
<blockquote>
<p>文件的组成：</p>
</blockquote>
<ul>
<li>数据项<ul>
<li>基本数据项</li>
<li>组合数据项</li>
</ul>
</li>
<li>记录：数据项的集合</li>
<li>文件：<ul>
<li>记录式文件：由相似的记录组成</li>
<li>流式文件：字符流文件</li>
</ul>
</li>
</ul>
<blockquote>
<p>文件的属性</p>
</blockquote>
<ol>
<li>文件名</li>
<li>标识符</li>
<li>类型</li>
<li>位置</li>
</ol>
<blockquote>
<p>文件操作</p>
</blockquote>
<ol>
<li><p>文件的打开和关闭</p>
<p>将该文件的属性从外存拷贝到内存<strong>打开文件表</strong>的一个表目中，并将该表目的编号返回给用户。当用户需要操作的时候，可以利用系统返回的索引号向系统提出操作请求。关闭即关闭文件描述符</p>
</li>
<li><p>read write delete create</p>
</li>
</ol>
<h4 id="文件的逻辑结构"><a href="#文件的逻辑结构" class="headerlink" title="文件的逻辑结构"></a>文件的逻辑结构</h4><blockquote>
<p>无结构文件（流式文件）</p>
</blockquote>
<p>只能通过穷举搜索的方式。对基本信息单位操作不多的文件较适用于采用无结构文件。源程序文件、目标代码文件。</p>
<blockquote>
<p>有结构文件（记录式文件）</p>
</blockquote>
<ol>
<li><p>顺序文件</p>
<p>记录定长，顺序排列</p>
<ol>
<li>存储方式：顺序存储、链式存储</li>
<li>结构：串结构、顺序结构（排序）</li>
</ol>
</li>
<li><p>索引文件</p>
<p>解决：顺序文件存储可变长记录效率低的文件</p>
</li>
<li><p>索引顺序文件</p>
<p>解决：索引文件中一个记录对应一个表项，占用过多的额外空间</p>
<p>改进为：一个索引对应一组记录</p>
<p>可以优化查询效率</p>
</li>
<li><p>多级索引顺序文件</p>
</li>
</ol>
<h4 id="文件的物理结构"><a href="#文件的物理结构" class="headerlink" title="文件的物理结构"></a>文件的物理结构</h4><h5 id="文件分配方式（磁盘非空闲区的管理）"><a href="#文件分配方式（磁盘非空闲区的管理）" class="headerlink" title="文件分配方式（磁盘非空闲区的管理）"></a>文件分配方式（磁盘非空闲区的管理）</h5><blockquote>
<p>连续分配</p>
</blockquote>
<p>优点：1. 实现简单 2. 存取速度快</p>
<p>缺点：1. 文件长度不宜动态增长 2. 产生外部碎片</p>
<blockquote>
<p>链接分配</p>
</blockquote>
<p>&#x3D;&#x3D;问题：外部碎片和文件大小&#x3D;&#x3D;</p>
<ul>
<li><p>隐式链接：</p>
<ul>
<li>优点：方便文件的拓展，不会出现外部碎片。外存利用率高。</li>
<li>缺点：只支持顺序访问，<strong>不支持随机访问</strong>，查找效率低</li>
</ul>
</li>
<li><p>显式链接</p>
<ul>
<li>问题1：需要将物理块读入内存，查找效率低</li>
<li>解决1：引入 <code>FAT</code>，一个磁盘只有一个 FAT，开机的时候读入 FAT，常驻内存</li>
<li>问题2：指针需要消耗内存</li>
<li>解决2：将多个块并在一起，形成一个<code>簇</code></li>
<li>缺点：文件分配表需要消耗一定的内存</li>
<li>优点：支持随机访问和顺序访问。</li>
</ul>
</li>
</ul>
<blockquote>
<p>索引分配</p>
</blockquote>
<p>问题：</p>
<ul>
<li>不能支持高效的随机存取，需要在 FAT 中顺序查找</li>
<li>FAT 需要占用较大的内存空间</li>
</ul>
<p>优点：支持随机访问，文件拓展容易实现</p>
<p>缺点：索引表需要占用比较多的空间</p>
<ol>
<li>单级索引分配</li>
<li>多级索引分配<ol>
<li>解决：单级索引分配索引表过大的问题</li>
</ol>
</li>
<li>混合索引分配</li>
</ol>
<h5 id="文件存储空间管理（磁盘空闲区的管理）"><a href="#文件存储空间管理（磁盘空闲区的管理）" class="headerlink" title="文件存储空间管理（磁盘空闲区的管理）"></a>文件存储空间管理（磁盘空闲区的管理）</h5><ul>
<li><p>空闲表法</p>
</li>
<li><p>空闲链表法</p>
<ul>
<li>空闲盘块法</li>
<li>空闲盘区法</li>
</ul>
</li>
<li><p>位示图法</p>
</li>
<li><p>成组链接法</p>
<p>问题：空闲表法、空闲链表法不适用于大型文件系统。</p>
<p>解决：引入超级块</p>
<ul>
<li>需要读入内存，并且保持数据一致性</li>
</ul>
</li>
</ul>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><p>解决：对文件实施有效的管理</p>
<ul>
<li><strong>实现 “按名存取” 基本功能</strong></li>
<li>提高对目录的检索速度</li>
<li>文件共享</li>
<li>允许文件重名</li>
</ul>
<blockquote>
<p>文件控制块 FDB</p>
</blockquote>
<p>用于描述和控制文件的数据结构。</p>
<p>描述了文件的文件名、物理地址、逻辑结构和物理结构。存取控制信息、使用信息</p>
<blockquote>
<p>目录结构</p>
</blockquote>
<ol>
<li><p>单级目录结构</p>
<p>优点：实现按名存取</p>
<p>缺点：不适用于多用户操作系统、查找速度慢、不允许重名</p>
</li>
<li><p>两级目录结构</p>
<p>优点：提高检索目录的速度、不同的用户目录中文件可以同名</p>
<p>缺点：无法文件共享</p>
</li>
<li><p>树形目录结构</p>
<p>引入相对路径的概念，减少了磁盘 IO 的次数</p>
<p>优点：可以很方便地对文件进行分类，层次结构清晰， 也能够更有效地进行文件的管理和保护。</p>
<p>缺点：不能实现文件共享</p>
</li>
<li><p>无环图目录结构</p>
<p>方面用户共享</p>
</li>
</ol>
<blockquote>
<p>索引节点</p>
</blockquote>
<p>问题：文件很多的时候，目录文件占用盘块</p>
<p>解决：文件名 + 文件描述信息，文件描述信息单独构成索引节点</p>
<p>使用 <code>stat filename</code> 或者 <code>ls -i</code> 可以查看索引节点</p>
<h2 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h2><ul>
<li><p>基于索引节点的共享方式（硬链接）</p>
</li>
<li><p>基于符号链的共享方式（软连接）</p>
</li>
</ul>
<h2 id="文件保护"><a href="#文件保护" class="headerlink" title="文件保护"></a>文件保护</h2><ul>
<li>口令保护：设置密码</li>
<li>加密保护：对文件加密，eg：异或加密</li>
<li>访问控制：chmod</li>
</ul>
<h2 id="磁盘调度"><a href="#磁盘调度" class="headerlink" title="磁盘调度"></a>磁盘调度</h2><ul>
<li>磁盘、磁道、扇区（块）</li>
<li>盘面、柱面(相对位置相同的磁道)</li>
</ul>
<p>磁盘读写时间 &#x3D; 寻道时间 + 延迟时间 + 传输时间</p>
<ul>
<li>寻道时间 &#x3D; 启动磁头时间 + 移动磁头的时间 （<strong>时间最长</strong>）</li>
<li>延迟时间 &#x3D; $\frac{1}{2r} &#x3D; \frac{T}{2}$</li>
<li>传出时间 &#x3D; $\frac{b}{N} \times \frac{1}{r}$</li>
</ul>
<ol>
<li><p>先来先服务 FCFS</p>
<p>优点：公平</p>
<p>缺点：FCFS 的性能很差</p>
</li>
<li><p>最短寻找时间优先 SSTF</p>
<p>优点：性能较好，平均寻道时间短</p>
<p>缺点：可能产生饥饿现象</p>
</li>
<li><p>扫描算法 SCAN 电梯算法</p>
<p>优点：性能较好，平均寻道时间较短，不会产生饥饿。</p>
<p>缺点：1. 只有到达需要访问的边界才能改变方向 2. <strong>对各个位置响应的频率不平均</strong></p>
</li>
<li><p>循环扫描算法 C-SCAN</p>
<p>优点：解决响应不平均的问题</p>
<p>缺点：平均寻道时间更长</p>
</li>
</ol>
<h2 id="文件系统维护命令"><a href="#文件系统维护命令" class="headerlink" title="文件系统维护命令"></a>文件系统维护命令</h2><ul>
<li><code>du</code>: 查看文件磁盘使用情况 <code>du [FILE]</code></li>
<li><code>df</code>: 查看文件所在磁盘剩余情况，<code>df [FILE]</code></li>
<li><code>free</code>: 查看系统的物理村内和虚拟内存的使用情况</li>
</ul>
<h1 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h1><h2 id="IO-系统"><a href="#IO-系统" class="headerlink" title="IO 系统"></a>IO 系统</h2><p>IO 设备：可以将数据输入到计算机，或者可以接受计算机输出数据的外部设备，属于计算机中的硬件部件</p>
<p>UNIX 将外部设备抽象成文件，用户可以使用与文件操作相同的方式对外部设备进行操作</p>
<ul>
<li>write：向外部设备写出数据</li>
<li>read：向外部设备读入数据</li>
</ul>
<p><strong>IO 系统的基本功能</strong></p>
<ul>
<li>隐藏物理设备的细节</li>
<li>与设备的无关性</li>
<li>提高处理及和 IO 设备的利用率</li>
<li>对 IO 设备进行控制：驱动</li>
<li>确保对设备的正确共享：独占设备（一段时间内一个）、共享设备（一个时刻一个）</li>
<li>错误处理</li>
</ul>
<p><strong>IO 软件的层次</strong></p>
<ol>
<li>用户层软件：实现与用户交互的接口</li>
<li>设备独立性软件：用户程序和驱动程序的统一接口</li>
<li>设备驱动程序：实现环境对设备发出指令</li>
<li>终端处理程序：保存 CPU 环境，装入中断处理</li>
</ol>
<blockquote>
<p>其中 2，3，4 属于操作系统的<strong>内核部分</strong>，即 IO 系统</p>
</blockquote>
<p><img src="/.com//image-20220418152350079.png" alt="image-20220418152350079"></p>
<blockquote>
<p>用户层软件</p>
</blockquote>
<p>功能：实现了与用户交互的接口（<strong>库函数</strong>），然后翻译成等价的<strong>系统调用</strong></p>
<blockquote>
<p>设备独立性软件</p>
</blockquote>
<p>功能：与硬件特性无关的功能几乎都在这一层实现</p>
<ul>
<li>向上提供统一的<strong>系统调用</strong>接口</li>
<li>设备保护：设置对设备文件的访问权限</li>
<li>差错处理：对设备的错误进行处理</li>
<li>设备的分配和回收</li>
<li>数据缓冲区管理</li>
<li>建立逻辑设备名到物理设备名的映射关系：逻辑设备表 LUT<ul>
<li>整个系统只设置一张 LUT，只适用与单用户操作系统，各个用户的逻辑设备名不能重复</li>
<li>为<strong>每个用户</strong>设置一张 LUT，存放在用户管理进程的 pcb 中，逻辑设备名可以重复</li>
<li>作用：记忆化进程使用的设备的映射关系</li>
</ul>
</li>
</ul>
<blockquote>
<p>驱动程序</p>
</blockquote>
<p>功能：将设备独立性软件的系统调用转化为具体操作</p>
<blockquote>
<p>中断处理程序</p>
</blockquote>
<p>计组中的中断处理程序</p>
<blockquote>
<p>总结</p>
</blockquote>
<ul>
<li>设备管理：设备独立性软件</li>
<li>涉及硬件的具体细节：设备驱动程序</li>
</ul>
<p><strong>设备与 CPU 之间的接口 – IO 控制器</strong></p>
<ul>
<li>与 CPU：数据、地址、控制线</li>
<li>与 设备：数据、状态、控制</li>
</ul>
<blockquote>
<p>功能 P197</p>
</blockquote>
<blockquote>
<p>组成：</p>
</blockquote>
<ul>
<li>与 CPU、设备的接口</li>
<li>数据寄存器：存储数据 <ul>
<li>CPU -&gt; 设备时，存储 CPU 的数据</li>
<li>设备 -&gt; CPU时，存储设备的数据</li>
</ul>
</li>
<li>控制寄存器：存储 CPU 发来的指令</li>
<li>状态寄存器</li>
<li>IO 逻辑：负责接受和识别 CPU 各种命令，对设备发出命令</li>
</ul>
<p><strong>内存映像IO</strong></p>
<p>问题：实现 CPU 和<strong>控制器</strong>交互</p>
<blockquote>
<p>利用特定的 IO 指令 （寄存器独立编址）</p>
</blockquote>
<p>使用不同的指令来对控制器操作</p>
<p>缺点：需要设置专门的 IO 指令来对控制器编址</p>
<blockquote>
<p>内存映像 IO （统一编址）</p>
</blockquote>
<p>将控制器和内存统一编址</p>
<p>优点：简化了指令。可以采用对进行操作的指令来对控制器操作</p>
<p><strong>IO 通道</strong></p>
<blockquote>
<p>什么是通道</p>
</blockquote>
<p>问题：虽然出现了控制器，但是 CPU 的负担依然很重</p>
<p>工作方式：CPU 向通道发送 IO 命令，通道执行通道程序，完成 IO 之后向 CPU 发出中断</p>
<p>与 CPU 的不同点：</p>
<ul>
<li>命令类型单一，仅能执行 IO 命令</li>
<li>没有自己的内存，通道程序存放在主存中</li>
</ul>
<blockquote>
<p>类型 P201</p>
</blockquote>
<ul>
<li><p>字节多路通道（字节传输）：是一种字节交叉方式工作的通道，采用多路分时复用 – 按时间片轮转方式共享主通道</p>
</li>
<li><p>数组选择通道（数组传输）：</p>
<ul>
<li>问题：字节多路通道不适用于连接高速设备</li>
<li>瓶颈：只有一个 IO 子通道，但是可以实现块传输</li>
<li>缺点：容易被一台设备独占，利用率低</li>
</ul>
</li>
<li><p>数组多路通道（数组传输）：</p>
<p>将上述两个技术结合在一起。使用于中高速的 IO 设备</p>
</li>
</ul>
<blockquote>
<p>瓶颈</p>
</blockquote>
<p>问题：由于<strong>通道价格昂贵</strong>，致使数量较少，使它成为I&#x2F;O系统的瓶颈 ，进而造成系统吞吐量的下降</p>
<p>解决：<strong>增加设备到主机间的通路</strong>而不增加通道</p>
<p><img src="/.com//image-20220418162042131.png" alt="image-20220418162042131"></p>
<h2 id="IO-控制方式"><a href="#IO-控制方式" class="headerlink" title="IO 控制方式"></a>IO 控制方式</h2><p>问题：如何告诉设备，CPU 需要设备做什么</p>
<blockquote>
<p>使用轮询的可编程 IO 方式</p>
</blockquote>
<p>优点：实现简单</p>
<p>缺点：CPU 和 IO 设备只能串行工作，CPU 需要一直轮询检查长期处于忙等状态，CPU 利用率低。</p>
<blockquote>
<p>中断驱动方式</p>
</blockquote>
<p>解决：引入中断机制</p>
<p>优点：CPU 和 IO 设备可以并行工作</p>
<p>缺点：频繁的中断处理会消耗较多的 CPU 时间</p>
<blockquote>
<p>DMA 方式 P211</p>
</blockquote>
<p>解决：引入 DMA 控制器</p>
<p><img src="/.com//image-20220418163200754.png" alt="image-20220418163200754"></p>
<p>优点：数据以块传输。CPU 和 IO 设备的并行得到提高</p>
<p>缺点：CPU 每发出一条 IO 指令，只能读写一个或多个<strong>连续</strong>的数据块。如果需要读取离散的数据块，则需要多条 IO 指令</p>
<blockquote>
<p>通道控制方式</p>
</blockquote>
<p>优点：每次读&#x2F;写<strong>一组</strong>数据块；CPU、通道、I&#x2F;O设备可并行工作，资源利用率很高</p>
<p>缺点：实现复杂，需要专门的通道硬件支持</p>
<p>指令格式：</p>
<p><img src="/.com//image-20220418163605709.png" alt="image-20220418163605709"></p>
<ul>
<li>操作码 </li>
<li>内存地址 &amp; 计数</li>
<li>通道<strong>程序</strong>结束位 P：1 表示这是<strong>最后一条</strong>指令</li>
<li><strong>记录</strong>结束标志位 R：1 表示这是处理某记录的最后一条指令</li>
</ul>
<blockquote>
<p>总结</p>
</blockquote>
<p><img src="/.com//image-20220418163928895.png" alt="image-20220418163928895"></p>
<blockquote>
<p>SPOOLing 技术</p>
</blockquote>
<p>需要多道程序技术的支持，</p>
<p>问题：独占设备 -&gt; 共享设备，缓和 CPU 和 IO 速度的不匹配</p>
<p>思想：空间换时间</p>
<p><strong>脱机技术</strong>：纸带机 -&gt; 外围控制机 -&gt; 磁带机 -&gt; CPU -&gt; 磁带机 -&gt; 外围控制机 -&gt; 纸带机</p>
<p>假脱机技术：输入设备 -&gt; 输入进程 -&gt; 输入井         输出井 -&gt; 输出进程 -&gt; 输出设备</p>
<ul>
<li>输入输出井 &#x3D; 磁盘</li>
<li>输入输出进程 &#x3D; 外围控制机</li>
<li>缓冲区用于暂存数据</li>
</ul>
<p><strong>模拟打印机</strong></p>
<ol>
<li>在<strong>输出井</strong>中开辟一段空间，用于存放数据</li>
<li>申请一张<strong>打印请求表</strong>（用于说明文件存放的位置），挂在文件队列上</li>
<li>输出进程根据表上的信息，将数据从外存 -&gt; 内存 -&gt; 打印机</li>
</ol>
<p><strong>特点</strong></p>
<ol>
<li>提高了 IO 速度：将 IO 操作变为对输入输出井的操作，提高了 IO 速度；缓和 CPU 和 IO 速度的不匹配</li>
<li>将独占设备改造成了共享设备</li>
<li>实现了虚拟设备功能</li>
</ol>
<h2 id="设备分配（设备独立性软件）"><a href="#设备分配（设备独立性软件）" class="headerlink" title="设备分配（设备独立性软件）"></a>设备分配（设备独立性软件）</h2><blockquote>
<p>设备的分配和回收</p>
</blockquote>
<p>问题：应用程序直接使用设备与系统中的物理设备直接相关，导致不灵活，给用户带来不便</p>
<p>解决：引入逻辑设备名</p>
<p>好处：</p>
<ul>
<li>逻辑设备是抽象的设备名</li>
<li>可实现 IO 重定向</li>
</ul>
<p><strong>逻辑设备名到物理设备名的映射 – 逻辑设备表</strong></p>
<ul>
<li>逻辑设备名</li>
<li>物理设备名</li>
<li>驱动程序入口地址</li>
</ul>
<blockquote>
<p>设备的固有属性</p>
</blockquote>
<ul>
<li>独占设备</li>
<li>共享设备</li>
<li>虚拟设备：采用 spooling 技术将独占设备改造成共享设备</li>
</ul>
<blockquote>
<p>设备分配算法</p>
</blockquote>
<ul>
<li>先来先服务</li>
<li>优先级高者优先</li>
<li>短任务优先</li>
</ul>
<blockquote>
<p>分配的安全性 PPT P79</p>
</blockquote>
<ul>
<li>安全分配方式：为进程分配一个设备之后，将进程阻塞，本次 IO 完成之后将进程唤醒<ul>
<li>优点：不会死锁，破坏 请求和保持 条件</li>
<li>缺点：串行工作</li>
</ul>
</li>
<li>不安全分配方式：进程发出 IO 请求之后，可以继续执行<ul>
<li>优点：并行工作</li>
<li>缺点：可能死锁</li>
</ul>
</li>
</ul>
<blockquote>
<p>分配方式</p>
</blockquote>
<ul>
<li><p>静态分配：开始就得到全部资源</p>
<p>破坏请求和保持条件，不会死锁</p>
</li>
<li><p>动态分配：动态申请</p>
</li>
</ul>
<blockquote>
<p>分配管理中的数据结构</p>
</blockquote>
<p>设备控制表 DCT：</p>
<ul>
<li>属性：类型、标识符、状态、指向控制器表的<strong>指针</strong></li>
<li>运行相关：重复执行次数、设备任务队列的队首 PCB 指针</li>
</ul>
<p>控制器控制表 COCT：</p>
<ul>
<li>属性：控制器标识符、状态、指向通道表的指针</li>
<li>运行相关：等待控制器的队首和队尾 PCB 指针</li>
</ul>
<p>通道控制表 CHCT：</p>
<ul>
<li>属性：标识符、状态、指向 COCT 的指针</li>
<li>运行相关：等待控制器的队首和队尾 PCB 指针</li>
</ul>
<p>系统设备表 SDT：</p>
<ul>
<li>包含系统中<strong>全部</strong>的<strong>设备</strong>情况<ul>
<li>设备类型、标识符、驱动程序入口</li>
<li>DCT</li>
</ul>
</li>
</ul>
<blockquote>
<p>设备分配步骤</p>
</blockquote>
<ol>
<li>根据进程请求的物理设备名查找 <strong>SDT</strong></li>
<li>根据 SDT 找到 DCT，<ol>
<li>忙碌：挂载进程 PCB 到设备等待队列</li>
<li>空闲：将设备分配给进程</li>
</ol>
</li>
<li>根据 DCT 找到 COCT，分配与上面相同</li>
<li>根据 COCT 找到 CHCT，分配与上面相同</li>
</ol>
<p>只有设备、控制器、通道三者都分配成功时，这次设备分配才算成功</p>
<p><strong>缺点 &amp; 问题</strong></p>
<ol>
<li>需要提供物理设备名，底层细节对用户不透明，不方便编程</li>
<li>程序不方便移植</li>
<li>同类型的设备利用率低</li>
</ol>
<p><strong>解决</strong></p>
<p><strong>引入逻辑设备名到物理设备名的映射</strong>。</p>
<ol>
<li><p>根据进程请求的<strong>逻辑设备名</strong>查找 <strong>SDT</strong></p>
</li>
<li><p>根据 SDT 找到 DCT，<strong>找到用户进程指定类型的、并且空闲的设备</strong>，将其分配给该进程。操作系统<strong>在逻辑设备表（LUT）中新增一个表项</strong>。</p>
<p>之后用户进程再次通过<strong>相同</strong>的逻辑设备名请求使用设备，则操作系统通过 LUT 表即可知道用户进程实际要使用的是哪个物理设备了，并且也能知道该设备的驱动程序入口地址</p>
<ol>
<li>忙碌：挂载进程 PCB 到设备等待队列</li>
<li>空闲：将设备分配给进程</li>
</ol>
</li>
<li><p>根据 DCT 找到 COCT，分配与上面相同</p>
</li>
<li><p>根据 COCT 找到 CHCT，分配与上面相同</p>
</li>
</ol>
<h2 id="缓冲区管理"><a href="#缓冲区管理" class="headerlink" title="缓冲区管理"></a>缓冲区管理</h2><p><strong>作用</strong></p>
<ol>
<li><strong>缓和 CPU 和 IO 设备之间速度不匹配的矛盾</strong></li>
<li><strong>减少对 CPU 的中断频率</strong>，放宽对 CPU 中断对应时间的限制</li>
<li>解决数据粒度不匹配的问题，CPU 一块一块输出，IO 设备一个字符输出</li>
<li>提高 CPU 和 IO 设备之间的并行性</li>
</ol>
<h3 id="缓冲区管理策略"><a href="#缓冲区管理策略" class="headerlink" title="缓冲区管理策略"></a>缓冲区管理策略</h3><p><strong>缓冲区特性</strong>：当缓冲区数据非空时，不能往缓冲区冲入数据，只能从缓冲区把数据传出；当缓冲区为 空时，可以往缓冲区传入数据，但必须把缓冲区充满以后，才能从缓冲区把数据传出。</p>
<p>掌握计算处理一块数据的平均时间</p>
<p>C: CPU 处理时间</p>
<p>M：IO 设备 -&gt; CPU 传送时间</p>
<p>T：IO 设备输入时间</p>
<blockquote>
<p>单缓冲区</p>
</blockquote>
<ul>
<li>T &gt; C</li>
</ul>
<p><img src="/.com//image-20220418212440750.png" alt="image-20220418212440750"></p>
<ul>
<li>T &lt; C</li>
</ul>
<p><img src="/.com//image-20220418212454284.png" alt="image-20220418212454284"></p>
<p>结论：max(C, T) + M</p>
<blockquote>
<p>双缓冲区</p>
</blockquote>
<ul>
<li>T &gt; M + C</li>
</ul>
<p><img src="/.com//image-20220418212825686.png" alt="image-20220418212825686"></p>
<ul>
<li><p>T &lt; M + C</p>
<p><img src="/.com//image-20220418212918197.png" alt="image-20220418212918197"></p>
</li>
</ul>
<p>结论：max(T, M + C)</p>
<blockquote>
<p>使用单双缓冲区在通信时的区别</p>
</blockquote>
<p>单缓冲区：半双工通信</p>
<p>双缓冲区：全双工通信</p>
<blockquote>
<p>循环缓冲区</p>
</blockquote>
<p>问题：当输入和输出的速度相差很大时，双缓冲效果不理想，但可增加缓冲 区的数量，改善情况</p>
<p>解决：引入循环队列逻辑结构的缓冲区</p>
<blockquote>
<p>缓冲池</p>
</blockquote>
<p>通过<strong>一系列缓冲区</strong>组成</p>
<p><img src="/.com//image-20220418214143500.png" alt="image-20220418214143500"></p>
<p><strong>缓冲区使用状况分类</strong></p>
<ul>
<li>空缓冲队列</li>
<li>输入队列</li>
<li>输出队列</li>
</ul>
<p><strong>缓冲区功能分类</strong></p>
<ul>
<li>用于<strong>收容输入</strong>数据的工作缓冲区（hin）</li>
<li>用于<strong>提取输入</strong>数据的工作缓冲区（sin）</li>
<li>用于<strong>收容输出</strong>数据的工作缓冲区（hout）</li>
<li>用于<strong>提取输出</strong>数据的工作缓冲区（sout）</li>
</ul>

        </div>

        
            <div class="post-copyright-info">
                <div class="article-copyright-info-container">
    <ul class="copyright-info-content">
        <li>本文标题：内存管理 &amp; 文件管理 &amp; IO 管理</li>
        <li>本文作者：auggie</li>
        <li>创建时间：2022-04-18 22:00:47</li>
        <li>
            本文链接：https://ruanjiancheng.github.io/2022/04/18/os/
        </li>
        <li>
            版权声明：本博客所有文章除特别声明外，均采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> 许可协议。转载请注明出处！
        </li>
    </ul>
</div>

            </div>
        

        
            <ul class="post-tags-box">
                
                    <li class="tag-item">
                        <a href="/tags/%E6%8A%80%E6%9C%AF/">#技术</a>&nbsp;
                    </li>
                
                    <li class="tag-item">
                        <a href="/tags/os/">#os</a>&nbsp;
                    </li>
                
            </ul>
        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/2022/04/25/database1/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">数据库原理一</span>
                                <span class="post-nav-item">上一篇</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/2022/04/18/vim/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">vim 基础学习</span>
                                <span class="post-nav-item">下一篇</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            
<footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
                <span>2021</span> -
            
            2022
            
                &nbsp;<i class="fas fa-heart icon-animate"></i>
                &nbsp;<a href="/">auggie</a>
            
        </div>
        
            <script async 
                    src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    访问人数&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;
                
                
            </div>
        
        <div class="theme-info info-item">
            由 <a target="_blank" href="https://hexo.io">Hexo</a> 驱动&nbsp;|&nbsp;主题
            &nbsp;
            <a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.9</a>
        </div>
        
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-up-right-and-down-left-from-center"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-text">内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="nav-text">程序的执行过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F"><span class="nav-text">内存分配方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D"><span class="nav-text">连续分配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A6%86%E7%9B%96"><span class="nav-text">覆盖</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E6%8D%A2%EF%BC%88%E4%BA%A4%E6%8D%A2%EF%BC%89"><span class="nav-text">对换（交换）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A6%BB%E6%95%A3%E5%88%86%E9%85%8D"><span class="nav-text">离散分配</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="nav-text">分页存储管理方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E6%AE%B5%E5%AD%98%E5%82%A8%E5%99%A8"><span class="nav-text">分段存储器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AE%B5%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E5%99%A8"><span class="nav-text">段页式存储器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8"><span class="nav-text">虚拟存储器</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-text">文件系统</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">文件系统的基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6"><span class="nav-text">文件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84"><span class="nav-text">文件的逻辑结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84"><span class="nav-text">文件的物理结构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F%EF%BC%88%E7%A3%81%E7%9B%98%E9%9D%9E%E7%A9%BA%E9%97%B2%E5%8C%BA%E7%9A%84%E7%AE%A1%E7%90%86%EF%BC%89"><span class="nav-text">文件分配方式（磁盘非空闲区的管理）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86%EF%BC%88%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B2%E5%8C%BA%E7%9A%84%E7%AE%A1%E7%90%86%EF%BC%89"><span class="nav-text">文件存储空间管理（磁盘空闲区的管理）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%AE%E5%BD%95"><span class="nav-text">目录</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB"><span class="nav-text">文件共享</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E4%BF%9D%E6%8A%A4"><span class="nav-text">文件保护</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6"><span class="nav-text">磁盘调度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4%E5%91%BD%E4%BB%A4"><span class="nav-text">文件系统维护命令</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86"><span class="nav-text">设备管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#IO-%E7%B3%BB%E7%BB%9F"><span class="nav-text">IO 系统</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IO-%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="nav-text">IO 控制方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BE%E5%A4%87%E5%88%86%E9%85%8D%EF%BC%88%E8%AE%BE%E5%A4%87%E7%8B%AC%E7%AB%8B%E6%80%A7%E8%BD%AF%E4%BB%B6%EF%BC%89"><span class="nav-text">设备分配（设备独立性软件）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA%E7%AE%A1%E7%90%86"><span class="nav-text">缓冲区管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5"><span class="nav-text">缓冲区管理策略</span></a></li></ol></li></ol></li></ol>
    </div>
</div>
        </aside>
    

    <div class="zoom-in-image-mask">
    <img class="zoom-in-image">
</div>


    

</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/dark-light-toggle.js"></script>







    
<script src="/js/code-block-tools.js"></script>





<div class="post-scripts">
    
        
<script src="/js/left-side-toggle.js"></script>

<script src="/js/libs/anime.min.js"></script>

<script src="/js/toc.js"></script>

    
</div>



</body>
</html>
